#include "maze.h"
#include <string.h>
#include <random.h>
#include <vga.h>

#define CHAR_EMPTY '.'
#define CHAR_PLAYER '@'
#define CHAR_KEY 'J'
#define CHAR_DOOR '>'

import s8 trap();

#define MAZE_ARRAY_SIZE (MAZE_MAX_SIDE * MAZE_MAX_SIDE)

u8 maze_data[MAZE_ARRAY_SIZE];
u8 width;
u8 height;

u8 get_wall_char(u8 top, u8 bottom, u8 left, u8 right);

export u8 maze_init(u8 w, u8 h)
{
    memset((u8*)maze_data, MAZE_WALL, (u16)w * (u16)h);
    width = w;
    height = h;
}

#define DFS_STACK_SIZE 4096

export u8 maze_dfs(u8 ux, u8 uy)
{
    u8 directions[4];
    u8 i;
    u16 index;
    s8 stack[DFS_STACK_SIZE];
    s8 *sp = (s8*)stack;

    *sp = (s8)ux;
    *(sp + 1) = (s8)uy;
    *(sp + 2) = (s8)ux;
    *(sp + 3) = (s8)uy;
    sp += 4;
    directions[0] = NORTH;
    directions[1] = EAST;
    directions[2] = SOUTH;
    directions[3] = WEST;

    while (sp != (s8*)stack)
    {
        sp += -4;
        s8 x = *sp;
        s8 y = *(sp + 1);
        s8 xl = *(sp + 2);
        s8 yl = *(sp + 3);

        index = (u16)x + (u16)y * (u16)width;
        if (maze_data[index])
            continue;
        maze_data[index] = MAZE_PASSAGE;
        index = (((u16)xl + (u16)yl * (u16)width) + index) >> (u8)1; // wall between squares
        maze_data[index] = MAZE_PASSAGE;
        xl = x;
        yl = y;

        i = (u8)4;
        while (i > (u8)1) {
            u16 n;
            u8 t;
            n = random((u16)i);
            t = directions[(s16)i - 1];
            directions[(s16)i - 1] = directions[n];
            directions[n] = t;
            i -= (u8)1;
        }

        i = (u8)0;
        while (i < (u8)4) {
            s8 xn;
            s8 yn;
            u8 dir = directions[(s16)i];

            xn = x;
            yn = y;
            if (dir == NORTH) {
                yn -= (s8)2;
            } else if (dir == EAST) {
                xn += (s8)2;
            } else if (dir == SOUTH) {
                yn += (s8)2;
            } else {
                xn -= (s8)2;
            }
            if (xn >= (s8)0 && yn >= (s8)0 && xn < (s8)width && yn < (s8)height) {
                *sp = xn;
                *(sp + 1) = yn;
                *(sp + 2) = x;
                *(sp + 3) = y;
                sp += 4;
            }
            i += (u8)1;
        }
    }
}

export u8 maze_get(s8 x, s8 y)
{
    if (x >= (s8)0 && x < (s8)width && y >= (s8)0 && y < (s8)height) {
        return maze_data[(u16)x + (u16)y * (u16)width];
    } else {
        return MAZE_WALL;
    }
}

export u8 maze_set(u8 x, u8 y, u8 v)
{
    maze_data[(u16)x + (u16)y * (u16)width] = v;
}

export u8 maze_show_all(u8 player_x, u8 player_y)
{
    u8 left = (VGA_COLS - width) >> 1u8;
    u8 top = (VGA_ROWS - width) >> 1u8;

    u8* screen_offset = (u8*)vga_char_seg + VGA_OFFSET(left, top);
    u16 maze_offset = 0u16;
    for (u8 y = 0u8; y < height; y += 1u8) {
        for (u8 x = 0u8; x < width; x += 1u8) {
            u8 c = CHAR_EMPTY;
            u8 e = maze_data[maze_offset];
            if (e == MAZE_WALL) {
                u8 l, r, t, b;
                if (x == 0u8) {
                    l = 1u8;
                } else {
                    l = maze_data[maze_offset - 1u16] == MAZE_WALL;
                }
                if (x == width - 1u8) {
                    r = 1u8;
                } else {
                    r = maze_data[maze_offset + 1u16] == MAZE_WALL;
                }
                if (y == 0u8) {
                    t = 1u8;
                } else {
                    t = maze_data[maze_offset - (u16)width] == MAZE_WALL;
                }
                if (y == height - 1u8) {
                    b = 1u8;
                } else {
                    b = maze_data[maze_offset + (u16)width] == MAZE_WALL;
                }
                c = get_wall_char(t, b, l, r);
            } else if (e == MAZE_KEY) {
                c = CHAR_KEY;
            } else if (e == MAZE_EXIT) {
                c = CHAR_DOOR;
            }
            vga_set(screen_offset, c);

            maze_offset += 1u16;
            screen_offset += 1u8;
        }
        screen_offset += 128u8;
        screen_offset -= (s16)width;
    }

    // draw frame
    if (top > 0u8) {
        screen_offset = (u8*)vga_char_seg + VGA_OFFSET(left - 1u8, top - 1u8);
        maze_offset = 0u16;
        vga_set(screen_offset, 218u8);
        screen_offset += 1u8;
        for (x = 0u8; x < width; x += 1u8) {
            c = 196u8;
            if (maze_data[maze_offset] == MAZE_WALL) {
                c = 194u8;
            }
            vga_set(screen_offset, c);
            maze_offset += 1u16;
            screen_offset += 1u8;
        }
        vga_set(screen_offset, 191u8);
    }
    if (top + height < VGA_COLS) {
        screen_offset = (u8*)vga_char_seg + VGA_OFFSET(left - 1u8, top + height);
        maze_offset = (u16)width * (u16)(height - 1u8);
        vga_set(screen_offset, 192u8);
        screen_offset += 1u8;
        for (x = 0u8; x < width; x += 1u8) {
            c = 196u8;
            if (maze_data[maze_offset] == MAZE_WALL) {
                c = 193u8;
            }
            vga_set(screen_offset, c);
            maze_offset += 1u16;
            screen_offset += 1u8;
        }
        vga_set(screen_offset, 217u8);
    }
    screen_offset = (u8*)vga_char_seg + VGA_OFFSET(left - 1u8, top);
    maze_offset = 0u16;
    for (y = 0u8; y < height; y += 1u8) {
        c = 179u8;
        if (maze_data[maze_offset] == MAZE_WALL) {
            c = 195u8;
        }
        vga_set(screen_offset, c);
        maze_offset += (u16)(width - 1u8);
        screen_offset += width + 1u8;

        c = 179u8;
        if (maze_data[maze_offset] == MAZE_WALL) {
            c = 180u8;
        }
        vga_set(screen_offset, c);
        maze_offset += 1u16;
        screen_offset += 128u8 - 1u8 - width;
    }
    vga_set((u8*)vga_char_seg + VGA_OFFSET(left + player_x, top + player_y), CHAR_PLAYER);
}

export u8 maze_show_player_move(u8 from_x, u8 from_y, u8 to_x, u8 to_y)
{
    u8 left = (VGA_COLS - width) >> 1u8;
    u8 top = (VGA_ROWS - width) >> 1u8;

    vga_set((u8*)vga_char_seg + VGA_OFFSET(left + to_x, top + to_y), CHAR_PLAYER);
    vga_set((u8*)vga_char_seg + VGA_OFFSET(left + from_x, top + from_y), CHAR_EMPTY);
}

u8 get_wall_char(u8 top, u8 bottom, u8 left, u8 right)
{
    u8 index = top | (bottom << 1u8) | (left << 2u8) | (right << 3u8);
    // NSWE
    u8 *map = {
        254u8, // lone wall
        179u8, // N
        179u8, // S
        179u8, // NS

        196u8, // W
        217u8, // NW
        191u8, // SW
        180u8, // NSW

        196u8, // E
        192u8, // NE
        218u8, // SE
        195u8, // NSE

        196u8, // WE
        193u8, // NWE
        194u8, // SWE
        197u8 // NSWE
    };
    return map[index];
}
