#include "fat.h"
#include <card.h>
#include <string.h>

#define MAX_FILE_DESC 4u8

struct Partition {
    u8 boot; // 0x00
    u8 start_h; // 0x01
    u8 start_s; // 0x08
    u8 start_c; // 0x00
    u8 sys_id; // 0x06
    u8 end_h;  // 0x07
    u8 end_s; // 0x60
    u8 end_c; // 0xe4
    u32 rel_sector; // 0x00000027
    u32 n_sectors; // 0x0001e4d9
};

struct BPB {
        u8 jump[3];
        u8 oem_id[8];
        u16 bytes_per_sector; // 0x0200
    u8 sectors_per_cluster; // 0x04
    u16 n_reserved_sectors; // 0x0001
    u8 n_fats; // 0x02
    u16 n_dir_entries; // 0x0200
    u16 total_sectors; // 0x0000
        u8 media_descriptor_type; // 0xf8
    u16 sectors_per_fat; // 0x0079
        u16 sectors_per_track; // 0x0020
        u16 n_heads; // 0x0010
    u32 n_hidden_sectors; // 0x00000027
    u32 large_sectors; // 0x0001e4d9
};

struct FatInfo {
    u32 fat0_offset;
    u32 fat1_offset;
    u16 sectors_per_fat;
    u32 root_dir_offset;
    u8 log_sectors_per_cluster;
    u16 n_dir_entries;
    u32 data_offset;
};

struct FileDescriptor {
    u8 is_free;
    u16 last_cluster_len; // number of bytes in the last cluster in the chain
    u32 block_addr; // current block
    u8 block_in_cluster; // block index in current cluster
    u16 index_in_block; // read/write pointer in current block
    u16 next_cluster; // value from the FAT
    u16 cur_cluster; // index in the FAT
    struct FatDirEntry dir_entry;
    u32 dir_entry_block_addr; // block index on disc
    u16 dir_entry_index_in_block; // offset inside the block
    u8 is_root; // for directory descriptors: if this is a root directory (a special case)
    u8 dir_entry_modified; // need to write out the dir entry on file close
    u8 filler[10];
};

#define INVALID_BLOCK_ADDR 0xffffffffu32
u8 cache_block[CARD_BLOCK_SIZE];
u32 cache_block_addr;

struct FatInfo fat_info;
struct FileDescriptor file_desc[MAX_FILE_DESC];

export u8 fat_init() {
    for (u8 i = 0u8; i != MAX_FILE_DESC; i += 1u8) {
        file_desc[i].is_free = 1u8;
    }
    cache_block_addr = INVALID_BLOCK_ADDR;

    struct Partition partition;
    struct BPB bpb;
    u8 r = cache(0u32);
    if (r) {
        return FAT_ERROR_CARD;
    }
    memcpy((u8*)&partition, (u8*)cache_block + 446, sizeof(struct Partition));

    u32 offset = partition.rel_sector;
    r = cache(offset);
    if (r) {
        return FAT_ERROR_CARD;
    }
    memcpy((u8*)&bpb, (u8*)cache_block, sizeof(struct BPB));

    if (bpb.bytes_per_sector != 512u16) {
        return FAT_ERROR_UNSUPPORTED_SECTOR_SIZE;
    }
    offset = bpb.n_hidden_sectors;
    offset += (u32)bpb.n_reserved_sectors;
    fat_info.fat0_offset = offset; // 5000
    offset += (u32)bpb.sectors_per_fat;
    if (bpb.n_fats == 2u8) {
        fat_info.fat1_offset = offset;
        offset += (u32)bpb.sectors_per_fat;
    } else if (bpb.n_fats > 2u8) {
        return FAT_ERROR_TOO_MANY_FATS;
    }
    fat_info.root_dir_offset = offset; // 23400
    fat_info.sectors_per_fat = bpb.sectors_per_fat;
    fat_info.log_sectors_per_cluster = 0u8;
    while (bpb.sectors_per_cluster > 1u8) {
        fat_info.log_sectors_per_cluster += 1u8;
        bpb.sectors_per_cluster >>= 1u8;
    }
    fat_info.n_dir_entries = bpb.n_dir_entries;
    offset += (u32)((fat_info.n_dir_entries + 15u16) >> 4u8); // 27400
    fat_info.data_offset = offset;

    return 0u8;
}

// TODO BUG: can't go up ("..")
export u8 fat_open_dir(struct FatDirEntry *parent, u8 *name) {
    u8 fd, r;
    if ((u16)parent != 0u16) {
        fd = fat_open_file(parent, name);
        if (fd == FAT_BAD_DESC) {
            return FAT_BAD_DESC;
        }

        file_desc[fd].is_root = 0u8;
    } else {
        struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc;
        for (fd = 0u8; fd != MAX_FILE_DESC && !pfd->is_free; fd += 1u8) {
            pfd += 1u8;
        }
        if (fd == MAX_FILE_DESC) {
            return FAT_BAD_DESC;
        }
        pfd->is_free = 0u8;

        if (name == (u8*)0u8) {
            init_root_dir(pfd);
        } else {
            r = find_file(parent, name, pfd);
            if (!r) {
                pfd->is_free = 1u8;
                return FAT_BAD_DESC;
            }
            if (pfd->dir_entry.cluster_lo == 0u16) {
                init_root_dir(pfd);
            } else {
                init_fd(pfd);
            }
        }
    }
    return fd;
}

u8 cache(u32 block_addr) {
    if (cache_block_addr == block_addr) {
        return 0u8;
    }
    cache_block_addr = block_addr;
    u8 r = card_read_block(block_addr, (u8*)cache_block);
    if (r) {
        cache_block_addr = INVALID_BLOCK_ADDR;
    }
    return r;
}

u8 flush_cache() {
    if (cache_block_addr != INVALID_BLOCK_ADDR) {
        return card_write_block(cache_block_addr, (u8*)cache_block);
    } else {
        return 0u8;
    }
}

export u8 to_fat_name(u8 *dst, u8 *src) {
    u8 i, c;
    memset(dst, ' ', 11u16); // name + extension, all spaces
    if (*src == '.') {
        // just copy if it starts with a dot
        for (i = 0u8; i != 11u8; i += 1u8) {
            c = *src;
            if (!c) {
                return;
            }
            *dst = c;
            src += 1u8;
            dst += 1u8;
        }
        return;
    }
    for (i = 0u8; i != 8u8; i += 1u8) {
        c = *src;
        if (!c || c == '.') {
            break;
        }
        dst[i] = c;
        src += 1u8;
    }
    if (c == '.') {
        src += 1u8;
        c = *src;
    } else if (c) {
        while (c && c != '.') {
            src += 1u8;
            c = *src;
        }
    }
    for (i = 8u8; c && i != 11u8; i += 1u8) {
        dst[i] = c;
        src += 1u8;
        c = *src;
    }
}

export u8 from_fat_name(u8 *dst, u8 *src) {
    u8 i, c;
    for (i = 0u8; i != 8u8; i += 1u8) {
        c = src[i];
        if (c == ' ') {
            break;
        }
        *dst = c;
        dst += 1u8;
    }
    if (src[8] != ' ') {
        *dst = '.';
        dst += 1u8;
        for (i = 8u8; i != 11u8; i += 1u8) {
            c = src[i];
            if (c == ' ') {
                break;
            }
            *dst = c;
            dst += 1u8;
        }
    }
    *dst = 0u8;
}

// Find file in dir by name and fill out dir_entry-related fields in file descriptor
u8 find_file(struct FatDirEntry *dir, u8 *name, struct FileDescriptor *pfd) {
    u8 r;

    struct FileDescriptor fd;
    if (dir == (struct FatDirEntry *)0u8) {
        init_root_dir(&fd);
    } else {
        memcpy((u8*)&fd.dir_entry, (u8*)dir, sizeof(struct FatDirEntry));
        init_fd(&fd);
    }

    u8 fat_name[11];
    to_fat_name((u8*)fat_name, name);

    while (1u8) {
        r = cache(fd.block_addr);
        if (r) {
            return 0u8;
        }
        memcpy((u8*)&pfd->dir_entry, (u8*)cache_block + fd.index_in_block, sizeof(struct FatDirEntry));
        if (pfd->dir_entry.filename[0] == 0u8) {
            return 0u8;
        }
        r = memcmp((u8*)fat_name, (u8*)pfd->dir_entry.filename, 11u16);
        if (r == 0u8) {
            pfd->dir_entry_block_addr = fd.block_addr;
            pfd->dir_entry_index_in_block = fd.index_in_block;
            return 1u8;
        }
        seek_advance(&fd, sizeof(struct FatDirEntry));
    }
}

export u8 fat_get_next_dir_entry(u8 desc, struct FatDirEntry *dst, u8 attr_skip_mask) {
    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + desc;
    if (pfd->is_free) {
        return 0u8;
    }

    u8 r;
    while (1u8) {
        r = cache(pfd->block_addr);
        if (r) {
            return 0u8;
        }
        memcpy((u8*)dst, (u8*)cache_block + pfd->index_in_block, sizeof(struct FatDirEntry));

        seek_advance(pfd, sizeof(struct FatDirEntry));

        if (dst->filename[0] == 0u8) { // last entry
            return 0u8;
        }
        if (dst->filename[0] == 0xe5u8) { // empty entry
            continue;
        }
        if (dst->attrs == 0x0fu8) { // long filename
            continue;
        }
        if (dst->attrs & attr_skip_mask) {
            continue;
        }
        return 1u8;
    }
}

u16 read_fat_entry(u16 index) {
    u16 entry_offset = (u16)(u8)(index);
    u16 sector_index = index >> 8u8;
    u8 r;
    u32 disk_offset;
    disk_offset = fat_info.fat0_offset;
    disk_offset += (u32)sector_index;
    r = cache(disk_offset);
    if (r) {
        return 0u16;
    } else {
        return ((u16*)cache_block)[entry_offset];
    }
}

u16 alloc_cluster(u16 last) {
    u8 r;
    u16 result = 0u16;
    u32 block_addr = fat_info.fat0_offset;
    for (u16 fat_sector = 0u16; fat_sector != fat_info.sectors_per_fat; fat_sector += 1u16) {
        r = cache(block_addr);
        if (r) {
            return 0xffffu16;
        }
        for (u16 i = 0u16; i < (CARD_BLOCK_SIZE >> 1u16); i += 1u16) {
            u16 entry = ((u16*)cache_block)[i];
            if (entry == 0u16) {
                result += i;
                // write fat0
                ((u16*)cache_block)[i] = 0xffffu16;
                r = flush_cache();
                if (r) {
                    return 0xffffu16;
                }
                // write fat1
                r = cache(block_addr + fat_info.fat1_offset - fat_info.fat0_offset);
                if (r) {
                    return 0xffffu16;
                }
                ((u16*)cache_block)[i] = 0xffffu16;
                r = flush_cache();
                if (r) {
                    return 0xffffu16;
                }

                // now write its parent, start with fat1
                block_addr = fat_info.fat1_offset + (u32)(last >> 8u8);
                r = cache(block_addr);
                if (r) {
                    return 0xffffu16;
                }
                ((u16*)cache_block)[(u8)last] = result;
                r = flush_cache();
                if (r) {
                    return 0xffffu16;
                }
                r = cache(block_addr + fat_info.fat0_offset - fat_info.fat1_offset);
                if (r) {
                    return 0xffffu16;
                }
                ((u16*)cache_block)[(u8)last] = result;
                r = flush_cache();
                if (r) {
                    return 0xffffu16;
                }
                return result;
            }
        }
        block_addr += 1u32;
        result += CARD_BLOCK_SIZE >> 1u16;
    }
    return 0xffffu16;
}

import u8 print_u32(u8 col, u8 row, u32 v);

export u8 fat_open_file(struct FatDirEntry *dir, u8 *name) {
    for (u8 fd = 0u8; fd != MAX_FILE_DESC; fd += 1u8) {
        if (file_desc[fd].is_free) {
            break;
        }
    }
    if (fd == MAX_FILE_DESC) {
        return FAT_BAD_DESC;
    }

    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + fd;
    pfd->is_free = 0u8;
    u8 r = find_file(dir, name, pfd);
    if (!r) {
        pfd->is_free = 1u8;
        return FAT_BAD_DESC;
    }

    init_fd(pfd);
    return fd;
}

u8 init_fd(struct FileDescriptor *pfd) {
    pfd->is_root = 0u8;
    u16 cluster_mask = ~(0xffffu16 << (fat_info.log_sectors_per_cluster + 9u8));
    pfd->last_cluster_len = (u16)pfd->dir_entry.size & cluster_mask;

    pfd->block_addr = fat_info.data_offset;
    pfd->block_addr += (u32)(pfd->dir_entry.cluster_lo - 2u16) << fat_info.log_sectors_per_cluster;
    pfd->block_in_cluster = 0u8;
    pfd->index_in_block = 0u16;
    pfd->next_cluster = read_fat_entry(pfd->dir_entry.cluster_lo);
    pfd->cur_cluster = pfd->dir_entry.cluster_lo;
    pfd->dir_entry_modified = 0u8;
}

u8 init_root_dir(struct FileDescriptor *pfd) {
    pfd->is_root = 1u8;
    pfd->block_addr = fat_info.root_dir_offset;
    pfd->block_in_cluster = 0u8;
    pfd->index_in_block = 0u16;
    pfd->dir_entry_modified = 0u8;
}

export u16 fat_read(u8 fd, u8 *dst, u16 len) {
    return fat_action(fd, dst, len, 0u8);
}

u8 seek_advance(struct FileDescriptor *pfd, u16 advance) {
    pfd->index_in_block += advance;
    if (pfd->index_in_block == CARD_BLOCK_SIZE) {
        pfd->block_in_cluster += 1u8;
        pfd->index_in_block = 0u16;
        if (pfd->block_in_cluster >> fat_info.log_sectors_per_cluster) {
            // next cluster
            if (pfd->is_root) {
                pfd->block_addr += 1u32;
            } else {
                pfd->block_addr = fat_info.data_offset;
                pfd->block_addr += (u32)(pfd->next_cluster - 2u16) << fat_info.log_sectors_per_cluster;
                pfd->cur_cluster = pfd->next_cluster;
                pfd->next_cluster = read_fat_entry(pfd->cur_cluster);
                pfd->block_in_cluster = 0u8;
            }
        } else {
            // next block in cluster
            pfd->block_addr += 1u32;
        }
    }
}

u8 seek_begin(struct FileDescriptor *pfd) {
    pfd->block_addr = fat_info.data_offset;
    pfd->block_addr += (u32)(pfd->dir_entry.cluster_lo - 2u16) << fat_info.log_sectors_per_cluster;
    pfd->block_in_cluster = 0u8;
    pfd->index_in_block = 0u16;
    pfd->next_cluster = read_fat_entry(pfd->dir_entry.cluster_lo);
    pfd->cur_cluster = pfd->dir_entry.cluster_lo;
}

export u16 fat_write(u8 fd, u8 *src, u16 len) {
    return fat_action(fd, src, len, 1u8);
}

u16 fat_action(u8 fd, u8 *data, u16 len, u8 is_write) {
    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + fd;
    if (pfd->is_free) {
        return 0u16;
    }
    u16 result = 0u16;
    u8 r;
    while (len != 0u16) {
        u16 chunk_len = CARD_BLOCK_SIZE - pfd->index_in_block;
        if (pfd->next_cluster >= 0xFFF8u16) {
            // last cluster
            u16 remainder = pfd->last_cluster_len - ((u16)pfd->block_in_cluster << 9u8);
            if (remainder <= CARD_BLOCK_SIZE) {
                // last block
                chunk_len = remainder - pfd->index_in_block;
                if (is_write) {
                    if (len > chunk_len) {
                        // expanding the file past the current size
                        chunk_len = len;
                        if (chunk_len + pfd->index_in_block > CARD_BLOCK_SIZE) {
                            // need to expand over current block
                            chunk_len = CARD_BLOCK_SIZE - pfd->index_in_block;
                        }
                        u16 delta_size = pfd->index_in_block + chunk_len - remainder;
                        pfd->last_cluster_len += delta_size;
                        pfd->dir_entry.size += (u32)delta_size;
                        pfd->dir_entry_modified = 1u8;
                        if (pfd->last_cluster_len == (CARD_BLOCK_SIZE << fat_info.log_sectors_per_cluster)) {
                            // need next block
                            u16 new_cluster = alloc_cluster(pfd->cur_cluster);
                            if (new_cluster == 0xffffu16) {
                                return result | 0x8000u16;
                            }
                            pfd->next_cluster = new_cluster;
                            pfd->last_cluster_len = 0u16;
                        }
                    }
                }
            }
        }
        if (chunk_len > len) {
            chunk_len = len;
        }
        if (chunk_len == 0u16) {
            return result;
        }
        r = cache(pfd->block_addr);
        if (r) {
            return result | 0x8000u16;
        }
        if (is_write) {
            memcpy((u8*)cache_block + pfd->index_in_block, data, chunk_len);
            r = flush_cache();
            if (r) {
                return result | 0x8000u16;
            }
        } else {
            memcpy(data, (u8*)cache_block + pfd->index_in_block, chunk_len);
        }
        len -= chunk_len;
        data += chunk_len;
        result += chunk_len;
        seek_advance(pfd, chunk_len);
    }
    return result;
}


export u8 fat_close(u8 fd) {
    struct FileDescriptor *pfd = (struct FileDescriptor*)file_desc + fd;
    if (pfd->dir_entry_modified) {
        cache(pfd->dir_entry_block_addr);
        memcpy((u8*)cache_block + pfd->dir_entry_index_in_block, (u8*)&pfd->dir_entry, sizeof(struct FatDirEntry));
        flush_cache();
    }
    pfd->is_free = 1u8;
}
