#include "fat.h"
#include <card.h>

#define MAX_DIR_DESC 1u8

struct Partition {
    u8 boot; // 0x00
    u8 start_h; // 0x01
    u8 start_s; // 0x08
    u8 start_c; // 0x00
    u8 sys_id; // 0x06
    u8 end_h;  // 0x07
    u8 end_s; // 0x60
    u8 end_c; // 0xe4
    u32 rel_sector; // 0x00000027
    u32 n_sectors; // 0x0001e4d9
};

struct BPB {
        u8 jump[3];
        u8 oem_id[8];
        u16 bytes_per_sector; // 0x0200
    u8 sectors_per_cluster; // 0x04
    u16 n_reserved_sectors; // 0x0001
    u8 n_fats; // 0x02
    u16 n_dir_entries; // 0x0200
    u16 total_sectors; // 0x0000
        u8 media_descriptor_type; // 0xf8
    u16 sectors_per_fat; // 0x0079
        u16 sectors_per_track; // 0x0020
        u16 n_heads; // 0x0010
    u32 n_hidden_sectors; // 0x00000027
    u32 large_sectors; // 0x0001e4d9
};

struct FatInfo {
    u32 fat0_offset;
    u32 fat1_offset;
    u16 sectors_per_fat;
    u32 root_dir_offset;
    u8 log_sectors_per_cluster;
    u16 n_dir_entries;
    u32 data_offset;
};


struct DirDescriptor {
    u8 is_free;
    u32 block_addr;
    u16 block_offset;
};

struct FileDescriptor {
    u8 is_free;
    u16 last_cluster_len; // number of bytes in the last cluster in the chain
    u32 block_addr; // current block
    u8 block_in_cluster; // block index in current cluster
    u16 index_in_block; // read pointer in current block
    u16 next_cluster; // value from the FAT
};

struct FatInfo fat_info;
struct DirDescriptor dir_desc; // TODO array
struct FileDescriptor file_desc; // TODO array

export u8 fat_init() {
    dir_desc.is_free = 1u8;
    file_desc.is_free = 1u8;

    struct Partition partition;
    struct BPB bpb;
    u8 r = card_read_block(0u32, 446u16, sizeof(struct Partition), (u8*)&partition);
    if (r) {
        return FAT_ERROR_CARD;
    }

    u32 offset = partition.rel_sector << 9u8;
    r = card_read_block(partition.rel_sector << 9u8, 0u16, sizeof(struct BPB), (u8*)&bpb);
    if (r) {
        return FAT_ERROR_CARD;
    }

    if (bpb.bytes_per_sector != 512u16) {
        return FAT_ERROR_UNSUPPORTED_SECTOR_SIZE;
    }
    offset = bpb.n_hidden_sectors << 9u8;
    offset += (u32)bpb.n_reserved_sectors << 9u8;
    fat_info.fat0_offset = offset; // 5000
    offset += (u32)bpb.sectors_per_fat << 9u8;
    if (bpb.n_fats == 2u8) {
        fat_info.fat1_offset = offset;
        offset += (u32)bpb.sectors_per_fat << 9u8;
    } else if (bpb.n_fats > 2u8) {
        return FAT_ERROR_TOO_MANY_FATS;
    }
    fat_info.root_dir_offset = offset; // 23400
    fat_info.sectors_per_fat = bpb.sectors_per_fat;
    fat_info.log_sectors_per_cluster = 0u8;
    while (bpb.sectors_per_cluster > 1u8) {
        fat_info.log_sectors_per_cluster += 1u8;
        bpb.sectors_per_cluster >>= 1u8;
    }
    fat_info.n_dir_entries = bpb.n_dir_entries;
    offset += (u32)((fat_info.n_dir_entries + 15u16) >> 4u8) << 9u8; // 27400
    fat_info.data_offset = offset;

    return 0u8;
}

export u8 fat_open_dir() {
    if (!dir_desc.is_free) {
        return FAT_BAD_DESC;
    }

    dir_desc.is_free = 0u8;
    dir_desc.block_addr = fat_info.root_dir_offset;
    dir_desc.block_offset = 0u16;
    return 0u8;
}

export u8 fat_get_next_dir_entry(u8 desc, struct FatDirEntry *dst) {
    while (1u8) {
        u8 r = card_read_block(dir_desc.block_addr, dir_desc.block_offset, sizeof(struct FatDirEntry), (u8*)dst);
        if (r) {
            return 0u8;
        }
        dir_desc.block_offset += sizeof(struct FatDirEntry);
        if (dir_desc.block_offset == CARD_BLOCK_SIZE) {
            dir_desc.block_offset = 0u16;
            dir_desc.block_addr += (u32)CARD_BLOCK_SIZE;
        }

        if (dst->filename[0] == 0u8) {
            return 0u8;
        }
        if (dst->filename[0] == 0xe5u8) {
            continue;
        }
        if (dst->attrs == 0x0fu8) {
            continue;
        }
        return 1u8;
    }
}

export u8 fat_close_dir(u8 dd) {
    dir_desc.is_free = 1u8;
}

u16 read_fat_entry(u16 index) {
    u16 sector_offset = (u16)(u8)(index) << 1u8;
    u16 sector_index = index >> 8u8;
    u16 result;
    u8 r;
    if (sector_index > 0u16) {
        u32 disk_offset;
        disk_offset = fat_info.fat0_offset;
        disk_offset += (u32)sector_index << 9u8;
        r = card_read_block(disk_offset, sector_offset, sizeof(u16), (u8*)&result);
    } else {
        r = card_read_block(fat_info.fat0_offset, sector_offset, sizeof(u16), (u8*)&result);
    }
    if (r) {
        return 0u16;
    } else {
        return result;
    }
}

export u8 fat_open_file(struct FatDirEntry *dsc) {
    if (!file_desc.is_free) {
        return FAT_BAD_DESC;
    }
    file_desc.is_free = 0u8;
    u8 cluster_bits = 9u8 + fat_info.log_sectors_per_cluster;
    u16 cluster_mask = ~(0xffffu16 << cluster_bits);
    file_desc.last_cluster_len = (u16)dsc->size[0] | ((u16)dsc->size[1] << 8u8);
    file_desc.last_cluster_len &= cluster_mask;

    file_desc.block_addr = fat_info.data_offset;
    file_desc.block_addr += (u32)(dsc->cluster_lo - 2u16) << (fat_info.log_sectors_per_cluster + 9u8);
    file_desc.block_in_cluster = 0u8;
    file_desc.index_in_block = 0u16;
    file_desc.next_cluster = read_fat_entry(dsc->cluster_lo);
    return 0u8;
}

export u16 fat_read(u8 fd, u8 *dst, u16 len) {
    if (file_desc.is_free) {
        return 0u16;
    }
    u16 result = 0u16;
    u8 r;
    while (len != 0u16) {
        u16 to_read;
        if (file_desc.next_cluster >= 0xFFF8u16) {
            // last cluster
            u16 remainder = file_desc.last_cluster_len - ((u16)file_desc.block_in_cluster << 9u8);
            if (remainder <= CARD_BLOCK_SIZE) {
                // last block
                to_read = remainder - file_desc.index_in_block;
            } else {
                to_read = CARD_BLOCK_SIZE - file_desc.index_in_block;
            }
        } else {
            to_read = CARD_BLOCK_SIZE - file_desc.index_in_block;
        }
        if (to_read > len) {
            to_read = len;
        }
        if (to_read == 0u16) {
            return result;
        }
        r = card_read_block(file_desc.block_addr, file_desc.index_in_block, to_read, dst);
        if (r) {
            return result | 0x8000u16;
        }
        len -= to_read;
        dst += to_read;
        result += to_read;
        file_desc.index_in_block += to_read;
        if (file_desc.index_in_block == CARD_BLOCK_SIZE) {
            file_desc.block_in_cluster += 1u8;
            file_desc.index_in_block = 0u16;
            if (file_desc.block_in_cluster >> fat_info.log_sectors_per_cluster) {
                // next cluster
                file_desc.block_addr = fat_info.data_offset;
                file_desc.block_addr += (u32)(file_desc.next_cluster - 2u16) << (fat_info.log_sectors_per_cluster + 9u8);
                file_desc.next_cluster = read_fat_entry(file_desc.next_cluster);
                file_desc.block_in_cluster = 0u8;
            } else {
                // next block in cluster
                file_desc.block_addr += (u32)CARD_BLOCK_SIZE;
            }
        }
    }
    return result;
}

export u8 fat_close_file(u8 fd) {
    file_desc.is_free = 1u8;
}
