#include "fat.h"
#include <card.h>

#define MAX_DIR_DESC 1u8

struct Partition {
    u8 boot; // 0x00
    u8 start_h; // 0x01
    u8 start_s; // 0x08
    u8 start_c; // 0x00
    u8 sys_id; // 0x06
    u8 end_h;  // 0x07
    u8 end_s; // 0x60
    u8 end_c; // 0xe4
    u8 rel_sector[4]; // 0x00000027
    u8 n_sectors[4]; // 0x0001e4d9
};

struct BPB {
        u8 jump[3];
        u8 oem_id[8];
        u16 bytes_per_sector; // 0x0200
    u8 sectors_per_cluster; // 0x04
    u16 n_reserved_sectors; // 0x0001
    u8 n_fats; // 0x02
    u16 n_dir_entries; // 0x0200
    u16 total_sectors; // 0x0000
        u8 media_descriptor_type; // 0xf8
    u16 sectors_per_fat; // 0x0079
        u16 sectors_per_track; // 0x0020
        u16 n_heads; // 0x0010
    u8 n_hidden_sectors[4]; // 0x00000027
    u8 large_sectors[4]; // 0x0001e4d9
};

struct FatInfo {
    u8 fat0_offset[4];
    u8 fat1_offset[4];
    u16 sectors_per_fat;
    u8 root_dir_offset[4];
    u8 log_sectors_per_cluster;
    u16 n_dir_entries;
    u8 data_offset[4];
};


struct DirDescriptor {
    u8 is_free;
    u8 block_addr[4];
    u16 block_offset;
};

struct FileDescriptor {
    u8 is_free;
    u16 last_cluster_len; // number of bytes in the last cluster in the chain
    u8 block_addr[4]; // current block
    u8 block_in_cluster; // block index in current cluster
    u16 index_in_block; // read pointer in current block
    u16 next_cluster; // value from the FAT
};


u8 u32_shl_9(u8 *p) {
    p[3] = (p[2] << 1u8) | (p[1] >> 7u8);
    p[2] = (p[1] << 1u8) | (p[0] >> 7u8);
    p[1] = p[0] << 1u8;
    p[0] = 0u8;
}

u8 u32_add(u8 *dst, u8 *src) {
    u16 carry = 0u16;
    for (u8 i = 0u8; i < 4u8; i += 1u8) {
        u16 r = (u16)dst[i] + (u16)src[i] + carry;
        dst[i] = (u8)r;
        carry = r >> 8u8;
    }
}

u8 u32_add_u16(u8 *dst, u16 src) {
    u16 r;
    r = (u16)dst[0] + (u16)(u8)src;
    dst[0] = (u8)r;
    r = (u16)dst[1] + (src >> 8u8) + (r >> 8u8);
    dst[1] = (u8)r;
    dst[2] = dst[2] + (u8)(r >> 8u8);
}

u8 u32_add_sectors(u8 *dst, u16 src) {
    if (src >= 0x8000u16) {
        dst[3] += 1u8;
        src &= 0x7FFFu16;
    }
    src <<= 1u8;
    u16 r;
    r = (u16)dst[1] + (u16)(u8)src;
    dst[1] = (u8)r;
    r >>= 8u8;
    src >>= 8u8;
    r = (u16)dst[2] + src + r;
    dst[2] = (u8)r;
    dst[3] += (u8)(r >> 8u8);
}

u8 u32_copy(u8 *dst, u8 *src) {
    dst[0] = src[0];
    dst[1] = src[1];
    dst[2] = src[2];
    dst[3] = src[3];
}

struct FatInfo fat_info;
struct DirDescriptor dir_desc; // TODO array
struct FileDescriptor file_desc; // TODO array

export u8 fat_init() {
    dir_desc.is_free = 1u8;
    file_desc.is_free = 1u8;

    struct Partition partition;
    struct BPB bpb;
    u8 r = card_read_block(0u16, 0u16, 446u16, sizeof(struct Partition), (u8*)&partition);
    if (r) {
        return FAT_ERROR_CARD;
    }

    u8 offset[4];
    u32_copy((u8*)offset, (u8*)partition.rel_sector);
    u32_shl_9((u8*)offset);
    r = card_read_block_u32((u8*)offset, 0u16, sizeof(struct BPB), (u8*)&bpb);
    if (r) {
        return FAT_ERROR_CARD;
    }

    if (bpb.bytes_per_sector != 512u16) {
        return FAT_ERROR_UNSUPPORTED_SECTOR_SIZE;
    }
    u32_copy((u8*)offset, (u8*)bpb.n_hidden_sectors);
    u32_shl_9((u8*)offset);
    u32_add_sectors((u8*)offset, (u16)bpb.n_reserved_sectors);
    u32_copy((u8*)fat_info.fat0_offset, (u8*)offset); // 5000
    u32_add_sectors((u8*)offset, bpb.sectors_per_fat);
    if (bpb.n_fats == 2u8) {
        u32_copy((u8*)fat_info.fat1_offset, (u8*)offset);
        u32_add_sectors((u8*)offset, bpb.sectors_per_fat);
    } else if (bpb.n_fats > 2u8) {
        return FAT_ERROR_TOO_MANY_FATS;
    }
    u32_copy((u8*)fat_info.root_dir_offset, (u8*)offset); // 23400
    fat_info.sectors_per_fat = bpb.sectors_per_fat;
    fat_info.log_sectors_per_cluster = 0u8;
    while (bpb.sectors_per_cluster > 1u8) {
        fat_info.log_sectors_per_cluster += 1u8;
        bpb.sectors_per_cluster >>= 1u8;
    }
    fat_info.n_dir_entries = bpb.n_dir_entries;
    u32_add_sectors((u8*)offset, (fat_info.n_dir_entries + 15u16) >> 4u8); // 27400
    u32_copy((u8*)fat_info.data_offset, (u8*)offset);

    return 0u8;
}

export u8 fat_open_dir() {
    if (!dir_desc.is_free) {
        return FAT_BAD_DESC;
    }

    dir_desc.is_free = 0u8;
    u32_copy((u8*)dir_desc.block_addr, (u8*)fat_info.root_dir_offset);
    dir_desc.block_offset = 0u16;
    return 0u8;
}

export u8 fat_get_next_dir_entry(u8 desc, struct FatDirEntry *dst) {
    while (1u8) {
        u8 r = card_read_block_u32((u8*)dir_desc.block_addr, dir_desc.block_offset, sizeof(struct FatDirEntry), (u8*)dst);
        if (r) {
            return 0u8;
        }
        dir_desc.block_offset += sizeof(struct FatDirEntry);
        if (dir_desc.block_offset == CARD_BLOCK_SIZE) {
            dir_desc.block_offset = 0u16;
            u32_add_sectors((u8*)dir_desc.block_addr, 1u16);
        }

        if (dst->filename[0] == 0u8) {
            return 0u8;
        }
        if (dst->filename[0] == 0xe5u8) {
            continue;
        }
        if (dst->attrs == 0x0fu8) {
            continue;
        }
        return 1u8;
    }
}

export u8 fat_close_dir(u8 dd) {
    dir_desc.is_free = 1u8;
}

u16 read_fat_entry(u16 index) {
    u16 sector_offset = (u16)(u8)(index) << 1u8;
    u16 sector_index = index >> 8u8;
    u16 result;
    u8 r;
    if (sector_index > 0u16) {
        u8 disk_offset[4];
        u32_copy((u8*)disk_offset, (u8*)fat_info.fat0_offset);
        u32_add_sectors((u8*)disk_offset, sector_index);
        r = card_read_block_u32((u8*)disk_offset, sector_offset, sizeof(u16), (u8*)&result);
    } else {
        r = card_read_block_u32((u8*)fat_info.fat0_offset, sector_offset, sizeof(u16), (u8*)&result);
    }
    if (r) {
        return 0u16;
    } else {
        return result;
    }
}

export u8 fat_open_file(struct FatDirEntry *dsc) {
    if (!file_desc.is_free) {
        return FAT_BAD_DESC;
    }
    file_desc.is_free = 0u8;
    u8 cluster_bits = 9u8 + fat_info.log_sectors_per_cluster;
    u16 cluster_mask = ~(0xffffu16 << cluster_bits);
    file_desc.last_cluster_len = (u16)dsc->size[0] | ((u16)dsc->size[1] << 8u8);
    file_desc.last_cluster_len &= cluster_mask;

    u32_copy((u8*)file_desc.block_addr, (u8*)fat_info.data_offset);
    u32_add_sectors((u8*)file_desc.block_addr, (dsc->cluster_lo - 2u16) << fat_info.log_sectors_per_cluster);
    file_desc.block_in_cluster = 0u8;
    file_desc.index_in_block = 0u16;
    file_desc.next_cluster = read_fat_entry(dsc->cluster_lo);
    return 0u8;
}

export u16 fat_read(u8 fd, u8 *dst, u16 len) {
    if (file_desc.is_free) {
        return 0u16;
    }
    u16 result = 0u16;
    u8 r;
    while (len != 0u16) {
        u16 to_read;
        if (file_desc.next_cluster >= 0xFFF8u16) {
            // last cluster
            u16 remainder = file_desc.last_cluster_len - ((u16)file_desc.block_in_cluster << 9u8);
            if (remainder <= CARD_BLOCK_SIZE) {
                // last block
                to_read = remainder - file_desc.index_in_block;
            } else {
                to_read = CARD_BLOCK_SIZE - file_desc.index_in_block;
            }
        } else {
            to_read = CARD_BLOCK_SIZE - file_desc.index_in_block;
        }
        if (to_read > len) {
            to_read = len;
        }
        if (to_read == 0u16) {
            return result;
        }
        r = card_read_block_u32((u8*)file_desc.block_addr, file_desc.index_in_block, to_read, dst);
        if (r) {
            return result | 0x8000u16;
        }
        len -= to_read;
        dst += to_read;
        result += to_read;
        file_desc.index_in_block += to_read;
        if (file_desc.index_in_block == CARD_BLOCK_SIZE) {
            file_desc.block_in_cluster += 1u8;
            file_desc.index_in_block = 0u16;
            if (file_desc.block_in_cluster >> fat_info.log_sectors_per_cluster) {
                // next cluster
                u32_copy((u8*)file_desc.block_addr, (u8*)fat_info.data_offset);
                u32_add_sectors((u8*)file_desc.block_addr, (file_desc.next_cluster - 2u16) << fat_info.log_sectors_per_cluster);
                file_desc.next_cluster = read_fat_entry(file_desc.next_cluster);
                file_desc.block_in_cluster = 0u8;
            } else {
                // next block in cluster
                u32_add_sectors((u8*)file_desc.block_addr, 1u16);
            }
        }
    }
    return result;
}

export u8 fat_close_file(u8 fd) {
    file_desc.is_free = 1u8;
}
