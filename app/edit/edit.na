#include <vga.h>
#include <line_edit.h>
#include <fat/error.h>
#include <last_error.h>
#include <os/syscall.h>
#include <os/params.h>
#include <more.h>
#include <log.h>
#include <ps2keyboard.h>
#include <string.h>

#define MAIN_COLOR COLOR(COLOR_GREEN, COLOR_BLACK)
#define TYPING_COLOR COLOR(COLOR_GREEN, COLOR_BLACK)
#define CURSOR_COLOR COLOR(COLOR_BLACK, COLOR_GREEN)
#define STATUS_COLOR COLOR(COLOR_LIGHT_RED, COLOR_BLACK)

#define MAX_LINES 480u16

struct Line {
    u8 len;
    u8 has_newline;
    struct Line *prev;
    struct Line *next;
    u8 data[58];
};

struct Line line_pool[MAX_LINES];

// where each screen before current starts:
struct Line *screen_ptrs[17]; // MAX_LINES / (u16)(VGA_ROWS - 1u8) + 1 - TODO fix compiler

// where each row on current screen starts
struct Line *row_ptrs[VGA_ROWS - 1u8];

// current screen index
u8 screen_idx;

// lines list head
struct Line *head;

// pool head and tail for allocating new lines
struct Line *pool_head;
struct Line *pool_tail;

section "sys_bss"
u8 buf[128];

section "sys_bss"
u8 filename_buf[40];

// actual file name
u8 *filename;

u8 load(u8 *filename) {
    u8 fd = open(filename);
    if (fd == FAT_BAD_DESC) {
        log_string("Can't open");
        log_u8(last_error);
        return 0u8;
    }
    screen_idx = 0u8;
    struct Line *p = (struct Line*)line_pool;
    for (u16 i = 0u16; i != MAX_LINES - 1u16; i += 1u16) {
        p->next = p + 1;
        p = p->next;
    }
    p->next = (struct Line *)0;
    pool_tail = p;
    pool_head = (struct Line*)line_pool;

    head = (struct Line*)line_pool;
    struct Line *cur_line = (struct Line*)line_pool;

    cur_line->len = 0u8;
    cur_line->prev = (struct Line*)0;
    cur_line->has_newline = 0u8;
    while (1u8) {
        u16 r16 = read(fd, (u8*)buf, sizeof(buf));
        u8 r8 = (u8)r16;
        for (u8 i8 = 0u8; i8 != r8; i8 += 1u8) {
            cur_line->data[cur_line->len] = buf[i8];
            cur_line->len += 1u8;
            if (buf[i8] == '\n' || cur_line->len == (u8)sizeof(cur_line->data)) {
                if (buf[i8] == '\n') {
                    cur_line->len -= 1u8;
                    cur_line->has_newline = 1u8;
                }
                p = cur_line;
                cur_line = cur_line->next;
                if ((u16)cur_line == 0u16) {
                    log_string("out of lines");
                    close(fd);
                    return 0u8;
                }
                cur_line->prev = p;
                cur_line->len = 0u8;
                cur_line->has_newline = 0u8;
            }
        }

        if (r16 != sizeof(buf)) {
            if (last_error != FAT_EOF) {
                log_string("Can't read");
                log_u8(last_error);
                close(fd);
                return 0u8;
            }
            break;
        }
    }
    cur_line->next = (struct Line*)0;
    close(fd);
    return 1u8;
}

u8 init_layout() {
    vga_clear(MAIN_COLOR);
    memset((u8*)vga_color_seg + VGA_OFFSET(0, VGA_ROWS - 1u8), STATUS_COLOR, (u16)VGA_COLS);
    vga_put_text(1u8, VGA_ROWS - 1u8, filename);
}

struct Line *show_lines(struct Line *start) {
    init_layout();
    u8 row = 0u8;
    while (row != VGA_ROWS - 1u8 && (u16)start != 0u16) {
        row_ptrs[row] = start;
        u8 *p = (u8*)vga_char_seg + VGA_OFFSET(0, row);
        for (u8 i = 0u8; i != start->len; i += 1u8) {
            u8 c = start->data[i];
            if (c != '\n') {
                *p = c;
            } else {
                *p = 0u8;
            }
            p += 1u8;
        }
        row += 1u8;
        start = start->next;
    }
    while (row != VGA_ROWS - 1u8) {
        row_ptrs[row] = (struct Line *)0u8;
        start = (struct Line *)0u8;
        row += 1u8;
    }
    return start;
}

export u8 main() {
    ps2_init();
    vga_clear(MAIN_COLOR);
    u8 r, fd;
    if ((u16)app_param1 == 0u16) {
        filename_buf[0] = 0u8;
        vga_put_text(0u8, 0u8, "Filename: ");
        r = line_edit((u8*)filename_buf, (u8)sizeof(filename_buf) - 1u8, 10u8, 0u8, MAIN_COLOR);
        if (!r) {
            return;
        }
        filename = (u8*)filename_buf;
    } else {
        filename = app_param1;
    }
    r = load(filename);
    if (!r) {
        return;
    }
    u8 cursor_col = 0u8;
    u8 cursor_row = 0u8;
    vga_color_seg[VGA_OFFSET(0, 0)] = CURSOR_COLOR;
    struct Line *next_screen = show_lines(head);
    screen_ptrs[0] = head;
    while (1u8) {
        u8 k = ps2_wait_key_pressed();
        if (k == PS2_KEY_UP) {
            if (cursor_row == 0u8) {
                if (screen_idx != 0u8) {
                    screen_idx -= 1u8;
                    next_screen = show_lines(screen_ptrs[screen_idx]);
                    cursor_row = VGA_ROWS - 2u8;
                    if (row_ptrs[cursor_row]->len < cursor_col) {
                        cursor_col = row_ptrs[cursor_row]->len;
                    }
                    vga_color_seg[VGA_OFFSET(cursor_col, cursor_row)] = CURSOR_COLOR;
                }
            } else {
                vga_color_seg[VGA_OFFSET(cursor_col, cursor_row)] = TYPING_COLOR;
                cursor_row -= 1u8;
                if (row_ptrs[cursor_row]->len < cursor_col) {
                    cursor_col = row_ptrs[cursor_row]->len;
                }
                vga_color_seg[VGA_OFFSET(cursor_col, cursor_row)] = CURSOR_COLOR;
            }
        } else if (k == PS2_KEY_DOWN) {
            if (cursor_row == VGA_ROWS - 2u8) {
                if ((u16)next_screen != 0u16) {
                    screen_idx += 1u8;
                    screen_ptrs[screen_idx] = next_screen;
                    next_screen = show_lines(next_screen);
                    cursor_row = 0u8;
                    if (row_ptrs[cursor_row]->len < cursor_col) {
                        cursor_col = row_ptrs[cursor_row]->len;
                    }
                    vga_color_seg[VGA_OFFSET(cursor_col, cursor_row)] = CURSOR_COLOR;
                }
            } else if ((u16)row_ptrs[cursor_row] != 0u16) {
                vga_color_seg[VGA_OFFSET(cursor_col, cursor_row)] = TYPING_COLOR;
                cursor_row += 1u8;
                if (row_ptrs[cursor_row]->len < cursor_col) {
                    cursor_col = row_ptrs[cursor_row]->len;
                }
                vga_color_seg[VGA_OFFSET(cursor_col, cursor_row)] = CURSOR_COLOR;
            }
        } else if (k == PS2_KEY_RIGHT) {
            if (cursor_col == row_ptrs[cursor_row]->len) {
                // TODO next line
            } else {
                vga_color_seg[VGA_OFFSET(cursor_col, cursor_row)] = TYPING_COLOR;
                cursor_col += 1u8;
                vga_color_seg[VGA_OFFSET(cursor_col, cursor_row)] = CURSOR_COLOR;
            }
        } else if (k == PS2_KEY_LEFT) {
            if (cursor_col == 0u8) {
                // TODO prev line
            } else {
                vga_color_seg[VGA_OFFSET(cursor_col, cursor_row)] = TYPING_COLOR;
                cursor_col -= 1u8;
                vga_color_seg[VGA_OFFSET(cursor_col, cursor_row)] = CURSOR_COLOR;
            }
        } else if (k == PS2_KEY_ESCAPE) {
            break;
        }
    }
}
