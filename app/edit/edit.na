#include <vga.h>
#include <line_edit.h>
#include <fat/error.h>
#include <last_error.h>
#include <os/syscall.h>
#include <os/params.h>
#include <more.h>
#include <log.h>
#include <ps2keyboard.h>
#include <string.h>

#define MAIN_COLOR COLOR(COLOR_GREEN, COLOR_BLACK)
#define TYPING_COLOR COLOR(COLOR_GREEN, COLOR_BLACK)
#define STATUS_COLOR COLOR(COLOR_LIGHT_RED, COLOR_BLACK)

#define MAX_LINES 480

struct Line {
    u8 len;
    struct Line *prev;
    struct Line *next;
    u8 data[59];
};

struct Line line_pool[MAX_LINES];

struct Line *head;

section "sys_bss"
u8 buf[59];

section "sys_bss"
u8 filename_buf[40];

u8 load(u8 *filename) {
    u8 fd = open(filename);
    if (fd == FAT_BAD_DESC) {
        log_string("Can't open");
        log_u8(last_error);
        return 0u8;
    }
    head = (struct Line*)line_pool;
    struct Line *cur_line = (struct Line*)line_pool;
    cur_line->len = 0u8;
    cur_line->prev = (struct Line*)0;
    while (1u8) {
        u16 r16 = read(fd, (u8*)buf, sizeof(cur_line->data));
        u8 r = (u8)r16;
        u8 *pc = (u8*)buf;
        u8 i = 0u8;
        while (r) {
            u8 c = *pc;
            cur_line->data[i] = c;
            pc += 1u8;
            r -= 1u8;
            i += 1u8;
            if (c == '\n' || i == (u8)sizeof(cur_line->data)) {
                cur_line->len = i;
                struct Line *next_line = cur_line + 1u8;
                if (next_line == (struct Line *)line_pool + MAX_LINES) {
                    log_string("Out of lines");
                    close(fd);
                    return 0u8;
                }
                cur_line->next = next_line;
                cur_line = next_line;
            }
        }
        if (r != sizeof(cur_line->data)) {
            if (last_error == FAT_EOF) {
                break;
            } else {

            }
        }
    }
    close(fd);
}

export u8 main() {
    ps2_init();
    vga_clear(MAIN_COLOR);
    u8 r, fd;
    u8 *filename;
    if ((u16)app_param1 == 0u16) {
        filename_buf[0] = 0u8;
        vga_put_text(0u8, 0u8, "Filename: ");
        r = line_edit((u8*)filename_buf, (u8)sizeof(filename_buf) - 1u8, 10u8, 0u8, MAIN_COLOR);
        if (!r) {
            return;
        }
        filename = (u8*)filename_buf;
    } else {
        filename = app_param1;
    }
    fd = open(app_param1);
    if (fd == FAT_BAD_DESC) {
        log_string("Can't open");
        log_u8(last_error);
        return;
    }
    u8 k = 1u8;

    u8 append = 0u8;
    while (1u8) {
        u8 row = 1u8;
        vga_clear(TYPING_COLOR);
        memset((u8*)vga_color_seg, STATUS_COLOR, (u16)VGA_COLS);
        if (append) {
            vga_put_text(0u8, 0u8, "Appending");
            vga_put_text(10u8, 0u8, (u8*)filename);
        } else {
            vga_put_text(0u8, 0u8, "Typing");
            vga_put_text(7u8, 0u8, (u8*)filename);
        }
        while (row != VGA_ROWS) {
            buf[0u8] = 0u8;
            r = line_edit((u8*)buf, (u8)sizeof(buf), 0u8, row, TYPING_COLOR);
            if (!r) {
                r = truncate(fd);
                if (!r) {
                    log_string("Can't truncate");
                    log_u8(last_error);
                }
                close(fd);
                return;
            }
            r = strlen_8((u8*)buf);
            buf[r] = '\n';
            buf[r + 1u8] = 0u8;
            u16 l = write(fd, (u8*)buf, (u16)(r + 1u8));
            if (l != (u16)(r + 1u8)) {
                log_string("Error writing");
                log_u8(last_error);
            }
            row += 1u8;
        }
    }
}
