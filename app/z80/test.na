#include <vga.h>
#include "z80run.h"

#define PASS_COLOR COLOR(COLOR_WHITE, COLOR_GREEN)
#define FAIL_COLOR COLOR(COLOR_WHITE, COLOR_RED)

#define TEST_COUNT 10u8

u8 test_number;


u8 get_test_number_row(u8 n) {
    return 0u8;
}

u8 get_test_number_col(u8 n) {
    return n * 4u8;
}

u8 ok() {
    u8 r = get_test_number_row(test_number);
    u8 c = get_test_number_col(test_number);
    u8 *p = (u8*)vga_color_seg + VGA_OFFSET(c, r);
    *p = PASS_COLOR;
    p += 1u8;
    *p = PASS_COLOR;
    p += 1u8;
    *p = PASS_COLOR;
    p += 1u8;
    *p = PASS_COLOR;
    p += 1u8;
}

u8 fail() {
    u8 r = get_test_number_row(test_number);
    u8 c = get_test_number_col(test_number);
    u8 *p = (u8*)vga_color_seg + VGA_OFFSET(c, r);
    *p = FAIL_COLOR;
    p += 1u8;
    *p = FAIL_COLOR;
    p += 1u8;
    *p = FAIL_COLOR;
    p += 1u8;
    *p = FAIL_COLOR;
    p += 1u8;
}

u8 draw_test_numbers() {
    u8 i = 0u8;
    for (; i != TEST_COUNT; i += 1u8) {
        u8 r = get_test_number_row(i);
        u8 c = get_test_number_col(i);
        vga_put_decimal_u16(c, r, (u16)i);
    }
}

#define HALT 0x76u8
import u16 z80_hl;
import u16 z80_de;
import u16 z80_bc;
import u16 z80_ix;
import u16 z80_iy;

import u8 z80_f;
import u8 z80_a;
import u8 z80_c;
import u8 z80_b;
import u8 z80_e;
import u8 z80_d;
import u8 z80_l;
import u8 z80_h;

#define ASSERT(b) if (!(b)) { fail(); return; }

u8 test_copy_reg() {
    test_number = 0u8;
    z80_a = 0xccu8;
    z80_b = 0xddu8;
    z80run({0x47u8, HALT}); // ld b, a
    ASSERT(z80_b == 0xccu8);

    z80_h = 0x5au8;
    z80run({0x7cu8, HALT}); // ld a, h
    ASSERT(z80_a == 0x5au8);
    ok();
}

u8 test_copy_r_indir() {
    test_number = 1u8;
    u8 var = 0x89u8;
    z80_hl = (u16)&var;
    z80_e = 0x00u8;
    z80run({0x5eu8, HALT}); // ld e, (hl)
    ASSERT(z80_e == 0x89u8);

    u32 var32 = 0x12345678u32;
    z80_c = 0x00u8;
    z80_d = 0x00u8;
    z80_ix = (u16)&var32 - 50u16;
    z80_iy = (u16)&var32 + 15u16;
    z80run({
        // ld c, (ix + 50)
        0xddu8, 0x4eu8, 50u8,
        // ld e, c
        0x59u8,
        // ld d, (iy - 14)
        0xfdu8, 0x56u8, (u8)-14s8,
        HALT
    });
    ASSERT(z80_c == 0x78u8);
    ASSERT(z80_e == 0x78u8);
    ASSERT(z80_d == 0x56u8);
    ok();
}

u8 test_store_indir_r() {
    test_number = 2u8;
    u8 dest1 = 0x00u8;
    u16 dest2 = 0x0000u16;
    z80_hl = (u16)&dest1;
    z80_c = 0x24u8;
    z80_d = 0xf9u8;
    z80_a = 0x42u8;
    z80_ix = (u16)&dest2 - 18u16;
    z80_iy = (u16)&dest2 + 100u16;
    z80run({
        // ld (hl), c
        0x71u8,
        // ld (ix + 19), d
        0xddu8, 0x72u8, 19u8,
        // ld (iy - 100), a
        0xfdu8, 0x77u8, (u8)-100s8,
        HALT
    });
    ASSERT(dest1 == 0x24u8);
    ASSERT(dest2 == 0xf942u16);
    z80_bc = (u16)&dest1;
    z80_de = (u16)&dest2 + 1u16;
    z80_a = 0xbcu8;
    z80run({
        // ld (bc), a
        0x02u8,
        HALT
    });
    ASSERT(dest1 == 0xbcu8);
    z80_a = 0xdeu8;
    z80run({
        // ld (de), a
        0x12u8,
        HALT
    });
    ASSERT(dest2 == 0xde42u16);
    ok();
}

u8 test_store_indir_imm() {
    test_number = 3u8;
    u8 dest1 = 0u8;
    u16 dest2 = 0u16;
    z80_hl = (u16)&dest1;
    z80_ix = (u16)&dest2 + 18u16;
    z80_iy = (u16)&dest2 - 100u16;
    z80run({
        // ld (hl), 0x33
        0x36u8, 0x33u8,
        // ld (ix - 18), 0x44
        0xddu8, 0x36u8, (u8)-18s8, 0x44u8,
        // ld (iy + 101), 0x55
        0xfdu8, 0x36u8, 101u8, 0x55u8,
        HALT
    });
    ASSERT(dest1 == 0x33u8);
    ASSERT(dest2 == 0x5544u16);
    ok();
}

u8 test_store_reg_imm() {
    test_number = 4u8;
    z80_a = 0u8;
    z80_b = 0u8;
    z80_c = 0u8;
    z80_d = 0u8;
    z80_e = 0u8;
    z80_h = 0u8;
    z80_l = 0u8;
    z80run({
        // ld a, 0x11
        0x3eu8, 0x11u8,
        // ld b, 0x22
        0x06u8, 0x22u8,
        // ld c, 0x33
        0x0eu8, 0x33u8,
        // ld d, 0x44
        0x16u8, 0x44u8,
        // ld e, 0x55
        0x1eu8, 0x55u8,
        // ld h, 0x66
        0x26u8, 0x66u8,
        // ld l, 0x77
        0x2eu8, 0x77u8,
        HALT
    });
    ASSERT(z80_a == 0x11u8);
    ASSERT(z80_b == 0x22u8);
    ASSERT(z80_c == 0x33u8);
    ASSERT(z80_d == 0x44u8);
    ASSERT(z80_e == 0x55u8);
    ASSERT(z80_h == 0x66u8);
    ASSERT(z80_l == 0x77u8);
    ok();
}

struct LdAIndir {
    u8 opcode;
    u8 *src;
    u8 halt;
};

u8 test_ld_a_indir_imm16() {
    test_number = 5u8;
    u8 src = 0x67u8;
    z80_a = 0u8;
    struct LdAIndir code;
    code.opcode = 0x3au8;
    code.src = &src;
    code.halt = HALT;
    z80run((u8*)&code);
    ASSERT(z80_a == 0x67u8);
    ok();
}

u8 test_ld_a_indir_bcde() {
    test_number = 6u8;
    u16 src = 0x1234u16;
    z80_a = 0u8;
    z80_bc = (u16)&src;
    z80_de = (u16)&src + 1u16;
    z80run({
        // ld a, (bc)
        0x0au8,
        HALT
    });
    ASSERT(z80_a == 0x34u8);
    z80run({
        // ld a, (de)
        0x1au8,
        HALT
    });
    ASSERT(z80_a == 0x12u8);
    ok();
}

export u8 main() {
    vga_clear(COLOR(COLOR_GRAY, COLOR_BLACK));
    test_number = 0u8;
    z80_a = 5u8;
    draw_test_numbers();
    test_copy_reg();
    test_copy_r_indir();
    test_store_indir_r();
    test_store_indir_imm();
    test_store_reg_imm();
    test_ld_a_indir_imm16();
    test_ld_a_indir_bcde();
}
